{"ast":null,"code":"import _objectSpread from \"/Users/chanchinghei/Desktop/\\u4E09\\u5927\\u53D4\\u667A\\u5546\\u7A0E/Web Development/repo-clones/food/recipe-app-copy/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/chanchinghei/Desktop/\\u4E09\\u5927\\u53D4\\u667A\\u5546\\u7A0E/Web Development/repo-clones/food/recipe-app-copy/client/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"autoplay\", \"delay\", \"driver\", \"keyframes\", \"type\", \"repeat\", \"repeatDelay\", \"repeatType\", \"onPlay\", \"onStop\", \"onComplete\", \"onUpdate\"];\nimport { keyframes } from '../../generators/keyframes.mjs';\nimport { spring } from '../../generators/spring/index.mjs';\nimport { inertia } from '../../generators/inertia.mjs';\nimport { frameloopDriver } from './driver-frameloop.mjs';\nimport { interpolate } from '../../../utils/interpolate.mjs';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../../utils/time-conversion.mjs';\nimport { calcGeneratorDuration } from '../../generators/utils/calc-duration.mjs';\nconst types = {\n  decay: inertia,\n  inertia,\n  tween: keyframes,\n  keyframes: keyframes,\n  spring\n};\n/**\n * Animate a single value on the main thread.\n *\n * This function is written, where functionality overlaps,\n * to be largely spec-compliant with WAAPI to allow fungibility\n * between the two.\n */\nfunction animateValue(_ref) {\n  let {\n      autoplay = true,\n      delay = 0,\n      driver = frameloopDriver,\n      keyframes: keyframes$1,\n      type = \"keyframes\",\n      repeat = 0,\n      repeatDelay = 0,\n      repeatType = \"loop\",\n      onPlay,\n      onStop,\n      onComplete,\n      onUpdate\n    } = _ref,\n    options = _objectWithoutProperties(_ref, _excluded);\n  let speed = 1;\n  let hasStopped = false;\n  let resolveFinishedPromise;\n  let currentFinishedPromise;\n  /**\n   * Resolve the current Promise every time we enter the\n   * finished state. This is WAAPI-compatible behaviour.\n   */\n  const updateFinishedPromise = () => {\n    currentFinishedPromise = new Promise(resolve => {\n      resolveFinishedPromise = resolve;\n    });\n  };\n  // Create the first finished promise\n  updateFinishedPromise();\n  let animationDriver;\n  const generatorFactory = types[type] || keyframes;\n  /**\n   * If this isn't the keyframes generator and we've been provided\n   * strings as keyframes, we need to interpolate these.\n   * TODO: Support velocity for units and complex value types/\n   */\n  let mapNumbersToKeyframes;\n  if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n    mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n      clamp: false\n    });\n    keyframes$1 = [0, 100];\n  }\n  const generator = generatorFactory(_objectSpread(_objectSpread({}, options), {}, {\n    keyframes: keyframes$1\n  }));\n  let mirroredGenerator;\n  if (repeatType === \"mirror\") {\n    mirroredGenerator = generatorFactory(_objectSpread(_objectSpread({}, options), {}, {\n      keyframes: [...keyframes$1].reverse(),\n      velocity: -(options.velocity || 0)\n    }));\n  }\n  let playState = \"idle\";\n  let holdTime = null;\n  let startTime = null;\n  let cancelTime = null;\n  /**\n   * If duration is undefined and we have repeat options,\n   * we need to calculate a duration from the generator.\n   *\n   * We set it to the generator itself to cache the duration.\n   * Any timeline resolver will need to have already precalculated\n   * the duration by this step.\n   */\n  if (generator.calculatedDuration === null && repeat) {\n    generator.calculatedDuration = calcGeneratorDuration(generator);\n  }\n  const {\n    calculatedDuration\n  } = generator;\n  let resolvedDuration = Infinity;\n  let totalDuration = Infinity;\n  if (calculatedDuration !== null) {\n    resolvedDuration = calculatedDuration + repeatDelay;\n    totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n  }\n  let currentTime = 0;\n  const tick = timestamp => {\n    if (startTime === null) return;\n    /**\n     * requestAnimationFrame timestamps can come through as lower than\n     * the startTime as set by performance.now(). Here we prevent this,\n     * though in the future it could be possible to make setting startTime\n     * a pending operation that gets resolved here.\n     */\n    if (speed > 0) startTime = Math.min(startTime, timestamp);\n    if (speed < 0) startTime = Math.min(timestamp - totalDuration / speed, startTime);\n    if (holdTime !== null) {\n      currentTime = holdTime;\n    } else {\n      // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n      // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n      // example.\n      currentTime = Math.round(timestamp - startTime) * speed;\n    }\n    // Rebase on delay\n    const timeWithoutDelay = currentTime - delay * (speed >= 0 ? 1 : -1);\n    const isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n    currentTime = Math.max(timeWithoutDelay, 0);\n    /**\n     * If this animation has finished, set the current time\n     * to the total duration.\n     */\n    if (playState === \"finished\" && holdTime === null) {\n      currentTime = totalDuration;\n    }\n    let elapsed = currentTime;\n    let frameGenerator = generator;\n    if (repeat) {\n      /**\n       * Get the current progress (0-1) of the animation. If t is >\n       * than duration we'll get values like 2.5 (midway through the\n       * third iteration)\n       */\n      const progress = currentTime / resolvedDuration;\n      /**\n       * Get the current iteration (0 indexed). For instance the floor of\n       * 2.5 is 2.\n       */\n      let currentIteration = Math.floor(progress);\n      /**\n       * Get the current progress of the iteration by taking the remainder\n       * so 2.5 is 0.5 through iteration 2\n       */\n      let iterationProgress = progress % 1.0;\n      /**\n       * If iteration progress is 1 we count that as the end\n       * of the previous iteration.\n       */\n      if (!iterationProgress && progress >= 1) {\n        iterationProgress = 1;\n      }\n      iterationProgress === 1 && currentIteration--;\n      currentIteration = Math.min(currentIteration, repeat + 1);\n      /**\n       * Reverse progress if we're not running in \"normal\" direction\n       */\n      const iterationIsOdd = Boolean(currentIteration % 2);\n      if (iterationIsOdd) {\n        if (repeatType === \"reverse\") {\n          iterationProgress = 1 - iterationProgress;\n          if (repeatDelay) {\n            iterationProgress -= repeatDelay / resolvedDuration;\n          }\n        } else if (repeatType === \"mirror\") {\n          frameGenerator = mirroredGenerator;\n        }\n      }\n      let p = clamp(0, 1, iterationProgress);\n      if (currentTime > totalDuration) {\n        p = repeatType === \"reverse\" && iterationIsOdd ? 1 : 0;\n      }\n      elapsed = p * resolvedDuration;\n    }\n    /**\n     * If we're in negative time, set state as the initial keyframe.\n     * This prevents delay: x, duration: 0 animations from finishing\n     * instantly.\n     */\n    const state = isInDelayPhase ? {\n      done: false,\n      value: keyframes$1[0]\n    } : frameGenerator.next(elapsed);\n    if (mapNumbersToKeyframes) {\n      state.value = mapNumbersToKeyframes(state.value);\n    }\n    let {\n      done\n    } = state;\n    if (!isInDelayPhase && calculatedDuration !== null) {\n      done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;\n    }\n    const isAnimationFinished = holdTime === null && (playState === \"finished\" || playState === \"running\" && done);\n    if (onUpdate) {\n      onUpdate(state.value);\n    }\n    if (isAnimationFinished) {\n      finish();\n    }\n    return state;\n  };\n  const stopAnimationDriver = () => {\n    animationDriver && animationDriver.stop();\n    animationDriver = undefined;\n  };\n  const cancel = () => {\n    playState = \"idle\";\n    stopAnimationDriver();\n    resolveFinishedPromise();\n    updateFinishedPromise();\n    startTime = cancelTime = null;\n  };\n  const finish = () => {\n    playState = \"finished\";\n    onComplete && onComplete();\n    stopAnimationDriver();\n    resolveFinishedPromise();\n  };\n  const play = () => {\n    if (hasStopped) return;\n    if (!animationDriver) animationDriver = driver(tick);\n    const now = animationDriver.now();\n    onPlay && onPlay();\n    if (holdTime !== null) {\n      startTime = now - holdTime;\n    } else if (!startTime || playState === \"finished\") {\n      startTime = now;\n    }\n    if (playState === \"finished\") {\n      updateFinishedPromise();\n    }\n    cancelTime = startTime;\n    holdTime = null;\n    /**\n     * Set playState to running only after we've used it in\n     * the previous logic.\n     */\n    playState = \"running\";\n    animationDriver.start();\n  };\n  if (autoplay) {\n    play();\n  }\n  const controls = {\n    then(resolve, reject) {\n      return currentFinishedPromise.then(resolve, reject);\n    },\n    get time() {\n      return millisecondsToSeconds(currentTime);\n    },\n    set time(newTime) {\n      newTime = secondsToMilliseconds(newTime);\n      currentTime = newTime;\n      if (holdTime !== null || !animationDriver || speed === 0) {\n        holdTime = newTime;\n      } else {\n        startTime = animationDriver.now() - newTime / speed;\n      }\n    },\n    get duration() {\n      const duration = generator.calculatedDuration === null ? calcGeneratorDuration(generator) : generator.calculatedDuration;\n      return millisecondsToSeconds(duration);\n    },\n    get speed() {\n      return speed;\n    },\n    set speed(newSpeed) {\n      if (newSpeed === speed || !animationDriver) return;\n      speed = newSpeed;\n      controls.time = millisecondsToSeconds(currentTime);\n    },\n    get state() {\n      return playState;\n    },\n    play,\n    pause: () => {\n      playState = \"paused\";\n      holdTime = currentTime;\n    },\n    stop: () => {\n      hasStopped = true;\n      if (playState === \"idle\") return;\n      playState = \"idle\";\n      onStop && onStop();\n      cancel();\n    },\n    cancel: () => {\n      if (cancelTime !== null) tick(cancelTime);\n      cancel();\n    },\n    complete: () => {\n      playState = \"finished\";\n    },\n    sample: elapsed => {\n      startTime = 0;\n      return tick(elapsed);\n    }\n  };\n  return controls;\n}\nexport { animateValue };","map":{"version":3,"names":["keyframes","spring","inertia","frameloopDriver","interpolate","clamp","millisecondsToSeconds","secondsToMilliseconds","calcGeneratorDuration","types","decay","tween","animateValue","_ref","autoplay","delay","driver","keyframes$1","type","repeat","repeatDelay","repeatType","onPlay","onStop","onComplete","onUpdate","options","_objectWithoutProperties","_excluded","speed","hasStopped","resolveFinishedPromise","currentFinishedPromise","updateFinishedPromise","Promise","resolve","animationDriver","generatorFactory","mapNumbersToKeyframes","generator","_objectSpread","mirroredGenerator","reverse","velocity","playState","holdTime","startTime","cancelTime","calculatedDuration","resolvedDuration","Infinity","totalDuration","currentTime","tick","timestamp","Math","min","round","timeWithoutDelay","isInDelayPhase","max","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","iterationIsOdd","Boolean","p","state","done","value","next","isAnimationFinished","finish","stopAnimationDriver","stop","undefined","cancel","play","now","start","controls","then","reject","time","newTime","duration","newSpeed","pause","complete","sample"],"sources":["/Users/chanchinghei/Desktop/三大叔智商税/Web Development/repo-clones/food/recipe-app-copy/client/node_modules/framer-motion/dist/es/animation/animators/js/index.mjs"],"sourcesContent":["import { keyframes } from '../../generators/keyframes.mjs';\nimport { spring } from '../../generators/spring/index.mjs';\nimport { inertia } from '../../generators/inertia.mjs';\nimport { frameloopDriver } from './driver-frameloop.mjs';\nimport { interpolate } from '../../../utils/interpolate.mjs';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../../utils/time-conversion.mjs';\nimport { calcGeneratorDuration } from '../../generators/utils/calc-duration.mjs';\n\nconst types = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\n/**\n * Animate a single value on the main thread.\n *\n * This function is written, where functionality overlaps,\n * to be largely spec-compliant with WAAPI to allow fungibility\n * between the two.\n */\nfunction animateValue({ autoplay = true, delay = 0, driver = frameloopDriver, keyframes: keyframes$1, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", onPlay, onStop, onComplete, onUpdate, ...options }) {\n    let speed = 1;\n    let hasStopped = false;\n    let resolveFinishedPromise;\n    let currentFinishedPromise;\n    /**\n     * Resolve the current Promise every time we enter the\n     * finished state. This is WAAPI-compatible behaviour.\n     */\n    const updateFinishedPromise = () => {\n        currentFinishedPromise = new Promise((resolve) => {\n            resolveFinishedPromise = resolve;\n        });\n    };\n    // Create the first finished promise\n    updateFinishedPromise();\n    let animationDriver;\n    const generatorFactory = types[type] || keyframes;\n    /**\n     * If this isn't the keyframes generator and we've been provided\n     * strings as keyframes, we need to interpolate these.\n     * TODO: Support velocity for units and complex value types/\n     */\n    let mapNumbersToKeyframes;\n    if (generatorFactory !== keyframes &&\n        typeof keyframes$1[0] !== \"number\") {\n        mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n            clamp: false,\n        });\n        keyframes$1 = [0, 100];\n    }\n    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n    let mirroredGenerator;\n    if (repeatType === \"mirror\") {\n        mirroredGenerator = generatorFactory({\n            ...options,\n            keyframes: [...keyframes$1].reverse(),\n            velocity: -(options.velocity || 0),\n        });\n    }\n    let playState = \"idle\";\n    let holdTime = null;\n    let startTime = null;\n    let cancelTime = null;\n    /**\n     * If duration is undefined and we have repeat options,\n     * we need to calculate a duration from the generator.\n     *\n     * We set it to the generator itself to cache the duration.\n     * Any timeline resolver will need to have already precalculated\n     * the duration by this step.\n     */\n    if (generator.calculatedDuration === null && repeat) {\n        generator.calculatedDuration = calcGeneratorDuration(generator);\n    }\n    const { calculatedDuration } = generator;\n    let resolvedDuration = Infinity;\n    let totalDuration = Infinity;\n    if (calculatedDuration !== null) {\n        resolvedDuration = calculatedDuration + repeatDelay;\n        totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n    }\n    let currentTime = 0;\n    const tick = (timestamp) => {\n        if (startTime === null)\n            return;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (speed > 0)\n            startTime = Math.min(startTime, timestamp);\n        if (speed < 0)\n            startTime = Math.min(timestamp - totalDuration / speed, startTime);\n        if (holdTime !== null) {\n            currentTime = holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            currentTime = Math.round(timestamp - startTime) * speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = currentTime - delay * (speed >= 0 ? 1 : -1);\n        const isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n        currentTime = Math.max(timeWithoutDelay, 0);\n        /**\n         * If this animation has finished, set the current time\n         * to the total duration.\n         */\n        if (playState === \"finished\" && holdTime === null) {\n            currentTime = totalDuration;\n        }\n        let elapsed = currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = currentTime / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const iterationIsOdd = Boolean(currentIteration % 2);\n            if (iterationIsOdd) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            let p = clamp(0, 1, iterationProgress);\n            if (currentTime > totalDuration) {\n                p = repeatType === \"reverse\" && iterationIsOdd ? 1 : 0;\n            }\n            elapsed = p * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes$1[0] }\n            : frameGenerator.next(elapsed);\n        if (mapNumbersToKeyframes) {\n            state.value = mapNumbersToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;\n        }\n        const isAnimationFinished = holdTime === null &&\n            (playState === \"finished\" || (playState === \"running\" && done));\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            finish();\n        }\n        return state;\n    };\n    const stopAnimationDriver = () => {\n        animationDriver && animationDriver.stop();\n        animationDriver = undefined;\n    };\n    const cancel = () => {\n        playState = \"idle\";\n        stopAnimationDriver();\n        resolveFinishedPromise();\n        updateFinishedPromise();\n        startTime = cancelTime = null;\n    };\n    const finish = () => {\n        playState = \"finished\";\n        onComplete && onComplete();\n        stopAnimationDriver();\n        resolveFinishedPromise();\n    };\n    const play = () => {\n        if (hasStopped)\n            return;\n        if (!animationDriver)\n            animationDriver = driver(tick);\n        const now = animationDriver.now();\n        onPlay && onPlay();\n        if (holdTime !== null) {\n            startTime = now - holdTime;\n        }\n        else if (!startTime || playState === \"finished\") {\n            startTime = now;\n        }\n        if (playState === \"finished\") {\n            updateFinishedPromise();\n        }\n        cancelTime = startTime;\n        holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        playState = \"running\";\n        animationDriver.start();\n    };\n    if (autoplay) {\n        play();\n    }\n    const controls = {\n        then(resolve, reject) {\n            return currentFinishedPromise.then(resolve, reject);\n        },\n        get time() {\n            return millisecondsToSeconds(currentTime);\n        },\n        set time(newTime) {\n            newTime = secondsToMilliseconds(newTime);\n            currentTime = newTime;\n            if (holdTime !== null || !animationDriver || speed === 0) {\n                holdTime = newTime;\n            }\n            else {\n                startTime = animationDriver.now() - newTime / speed;\n            }\n        },\n        get duration() {\n            const duration = generator.calculatedDuration === null\n                ? calcGeneratorDuration(generator)\n                : generator.calculatedDuration;\n            return millisecondsToSeconds(duration);\n        },\n        get speed() {\n            return speed;\n        },\n        set speed(newSpeed) {\n            if (newSpeed === speed || !animationDriver)\n                return;\n            speed = newSpeed;\n            controls.time = millisecondsToSeconds(currentTime);\n        },\n        get state() {\n            return playState;\n        },\n        play,\n        pause: () => {\n            playState = \"paused\";\n            holdTime = currentTime;\n        },\n        stop: () => {\n            hasStopped = true;\n            if (playState === \"idle\")\n                return;\n            playState = \"idle\";\n            onStop && onStop();\n            cancel();\n        },\n        cancel: () => {\n            if (cancelTime !== null)\n                tick(cancelTime);\n            cancel();\n        },\n        complete: () => {\n            playState = \"finished\";\n        },\n        sample: (elapsed) => {\n            startTime = 0;\n            return tick(elapsed);\n        },\n    };\n    return controls;\n}\n\nexport { animateValue };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}